# Program: CWE190_Integer_Overflow__char_fscanf_preinc_05
# Generated: 2025-08-08T23:23:32.325090Z

You are a security analyst. Analyze the FULL call flow(s) to the sink and produce a precise assessment.

Tasks:
1) Identify the exact vulnerable line(s) and function(s) along any BAD chain.
2) Explain the root cause (e.g., CWE-190 integer overflow due to pre-increment before bounds check).
3) If GOOD chains exist, point to the exact lines and mechanisms that mitigate the issue.
4) Name the vulnerability class and justify it.
5) If only a wrapper (e.g., FUN_*) is visible before the external sink, reason about the wrapperâ€™s role and the sink behavior.

=== ITEM 1 | SINK: __isoc99_fscanf ===

[BAD CHAIN 1] CWE190_Integer_Overflow__char_fscanf_preinc_05_bad -> __isoc99_fscanf
// CWE190_Integer_Overflow__char_fscanf_preinc_05_bad @ 001013c9

void FUN_001013c9(void)

{
  long in_FS_OFFSET;
  char local_12;
  char local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_12 = ' ';
  if (DAT_00104010 != 0) {
    __isoc99_fscanf(stdin,&DAT_00102008,&local_12);
  }
  if (DAT_00104010 != 0) {
    local_12 = local_12 + '\x01';
    local_11 = local_12;
    FUN_0010186b((int)local_12);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

// __isoc99_fscanf @ 001011a0


[GOOD CHAIN 1] goodB2G1 -> __isoc99_fscanf
// goodB2G1 @ 00101451

void FUN_00101451(void)

{
  long in_FS_OFFSET;
  char local_12;
  char local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_12 = ' ';
  if (DAT_00104010 != 0) {
    __isoc99_fscanf(stdin,&DAT_00102008,&local_12);
  }
  if (DAT_0010402c == 0) {
    if (local_12 == '\x7f') {
      FUN_001016f1("data value is too large to perform arithmetic safely.");
    }
    else {
      local_12 = local_12 + '\x01';
      local_11 = local_12;
      FUN_0010186b((int)local_12);
    }
  }
  else {
    FUN_001016f1("Benign, fixed string");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

// __isoc99_fscanf @ 001011a0


[GOOD CHAIN 2] goodB2G2 -> __isoc99_fscanf
// goodB2G2 @ 00101503

void FUN_00101503(void)

{
  long in_FS_OFFSET;
  char local_12;
  char local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_12 = ' ';
  if (DAT_00104010 != 0) {
    __isoc99_fscanf(stdin,&DAT_00102008,&local_12);
  }
  if (DAT_00104010 != 0) {
    if (local_12 == '\x7f') {
      FUN_001016f1("data value is too large to perform arithmetic safely.");
    }
    else {
      local_12 = local_12 + '\x01';
      local_11 = local_12;
      FUN_0010186b((int)local_12);
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

// __isoc99_fscanf @ 001011a0



---

=== ITEM 2 | SINK: printf ===

[BAD CHAIN 1] CWE190_Integer_Overflow__char_fscanf_preinc_05_bad -> FUN_0010186b -> printf
// CWE190_Integer_Overflow__char_fscanf_preinc_05_bad @ 001013c9

void FUN_001013c9(void)

{
  long in_FS_OFFSET;
  char local_12;
  char local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_12 = ' ';
  if (DAT_00104010 != 0) {
    __isoc99_fscanf(stdin,&DAT_00102008,&local_12);
  }
  if (DAT_00104010 != 0) {
    local_12 = local_12 + '\x01';
    local_11 = local_12;
    FUN_0010186b((int)local_12);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

// FUN_0010186b @ 0010186b

void FUN_0010186b(char param_1)

{
  printf("%02x\n",(ulong)(uint)(int)param_1);
  return;
}

// printf @ 001011e0


[GOOD CHAIN 1] goodB2G1 -> FUN_0010186b -> printf
// goodB2G1 @ 00101451

void FUN_00101451(void)

{
  long in_FS_OFFSET;
  char local_12;
  char local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_12 = ' ';
  if (DAT_00104010 != 0) {
    __isoc99_fscanf(stdin,&DAT_00102008,&local_12);
  }
  if (DAT_0010402c == 0) {
    if (local_12 == '\x7f') {
      FUN_001016f1("data value is too large to perform arithmetic safely.");
    }
    else {
      local_12 = local_12 + '\x01';
      local_11 = local_12;
      FUN_0010186b((int)local_12);
    }
  }
  else {
    FUN_001016f1("Benign, fixed string");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

// FUN_0010186b @ 0010186b

void FUN_0010186b(char param_1)

{
  printf("%02x\n",(ulong)(uint)(int)param_1);
  return;
}

// printf @ 001011e0


[GOOD CHAIN 2] goodB2G2 -> FUN_0010186b -> printf
// goodB2G2 @ 00101503

void FUN_00101503(void)

{
  long in_FS_OFFSET;
  char local_12;
  char local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_12 = ' ';
  if (DAT_00104010 != 0) {
    __isoc99_fscanf(stdin,&DAT_00102008,&local_12);
  }
  if (DAT_00104010 != 0) {
    if (local_12 == '\x7f') {
      FUN_001016f1("data value is too large to perform arithmetic safely.");
    }
    else {
      local_12 = local_12 + '\x01';
      local_11 = local_12;
      FUN_0010186b((int)local_12);
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

// FUN_0010186b @ 0010186b

void FUN_0010186b(char param_1)

{
  printf("%02x\n",(ulong)(uint)(int)param_1);
  return;
}

// printf @ 001011e0


[GOOD CHAIN 3] goodG2B1 -> FUN_0010186b -> printf
// goodG2B1 @ 001015a4

void FUN_001015a4(void)

{
  char local_a;
  
  local_a = ' ';
  if (DAT_0010402c == 0) {
    local_a = '\x02';
  }
  else {
    FUN_001016f1("Benign, fixed string");
  }
  if (DAT_00104010 != 0) {
    FUN_0010186b(local_a + '\x01');
  }
  return;
}

// FUN_0010186b @ 0010186b

void FUN_0010186b(char param_1)

{
  printf("%02x\n",(ulong)(uint)(int)param_1);
  return;
}

// printf @ 001011e0


[GOOD CHAIN 4] goodG2B2 -> FUN_0010186b -> printf
// goodG2B2 @ 001015fc

void FUN_001015fc(void)

{
  if (DAT_00104010 != 0) {
    FUN_0010186b(3);
  }
  return;
}

// FUN_0010186b @ 0010186b

void FUN_0010186b(char param_1)

{
  printf("%02x\n",(ulong)(uint)(int)param_1);
  return;
}

// printf @ 001011e0



---

=== ITEM 3 | SINK: __stack_chk_fail ===

[BAD CHAIN 1] CWE190_Integer_Overflow__char_fscanf_preinc_05_bad -> __stack_chk_fail
// CWE190_Integer_Overflow__char_fscanf_preinc_05_bad @ 001013c9

void FUN_001013c9(void)

{
  long in_FS_OFFSET;
  char local_12;
  char local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_12 = ' ';
  if (DAT_00104010 != 0) {
    __isoc99_fscanf(stdin,&DAT_00102008,&local_12);
  }
  if (DAT_00104010 != 0) {
    local_12 = local_12 + '\x01';
    local_11 = local_12;
    FUN_0010186b((int)local_12);
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

// __stack_chk_fail @ 001011d0


[GOOD CHAIN 1] goodB2G1 -> __stack_chk_fail
// goodB2G1 @ 00101451

void FUN_00101451(void)

{
  long in_FS_OFFSET;
  char local_12;
  char local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_12 = ' ';
  if (DAT_00104010 != 0) {
    __isoc99_fscanf(stdin,&DAT_00102008,&local_12);
  }
  if (DAT_0010402c == 0) {
    if (local_12 == '\x7f') {
      FUN_001016f1("data value is too large to perform arithmetic safely.");
    }
    else {
      local_12 = local_12 + '\x01';
      local_11 = local_12;
      FUN_0010186b((int)local_12);
    }
  }
  else {
    FUN_001016f1("Benign, fixed string");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

// __stack_chk_fail @ 001011d0


[GOOD CHAIN 2] goodB2G2 -> __stack_chk_fail
// goodB2G2 @ 00101503

void FUN_00101503(void)

{
  long in_FS_OFFSET;
  char local_12;
  char local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_12 = ' ';
  if (DAT_00104010 != 0) {
    __isoc99_fscanf(stdin,&DAT_00102008,&local_12);
  }
  if (DAT_00104010 != 0) {
    if (local_12 == '\x7f') {
      FUN_001016f1("data value is too large to perform arithmetic safely.");
    }
    else {
      local_12 = local_12 + '\x01';
      local_11 = local_12;
      FUN_0010186b((int)local_12);
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

// __stack_chk_fail @ 001011d0



---

=== ITEM 4 | SINK: puts ===

[GOOD CHAIN 1] goodB2G1 -> FUN_001016f1 -> puts
// goodB2G1 @ 00101451

void FUN_00101451(void)

{
  long in_FS_OFFSET;
  char local_12;
  char local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_12 = ' ';
  if (DAT_00104010 != 0) {
    __isoc99_fscanf(stdin,&DAT_00102008,&local_12);
  }
  if (DAT_0010402c == 0) {
    if (local_12 == '\x7f') {
      FUN_001016f1("data value is too large to perform arithmetic safely.");
    }
    else {
      local_12 = local_12 + '\x01';
      local_11 = local_12;
      FUN_0010186b((int)local_12);
    }
  }
  else {
    FUN_001016f1("Benign, fixed string");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

// FUN_001016f1 @ 001016f1

void FUN_001016f1(char *param_1)

{
  if (param_1 != (char *)0x0) {
    puts(param_1);
  }
  return;
}

// puts @ 001011b0


[GOOD CHAIN 2] goodB2G1 -> FUN_001016f1 -> puts
// goodB2G1 @ 00101451

void FUN_00101451(void)

{
  long in_FS_OFFSET;
  char local_12;
  char local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_12 = ' ';
  if (DAT_00104010 != 0) {
    __isoc99_fscanf(stdin,&DAT_00102008,&local_12);
  }
  if (DAT_0010402c == 0) {
    if (local_12 == '\x7f') {
      FUN_001016f1("data value is too large to perform arithmetic safely.");
    }
    else {
      local_12 = local_12 + '\x01';
      local_11 = local_12;
      FUN_0010186b((int)local_12);
    }
  }
  else {
    FUN_001016f1("Benign, fixed string");
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

// FUN_001016f1 @ 001016f1

void FUN_001016f1(char *param_1)

{
  if (param_1 != (char *)0x0) {
    puts(param_1);
  }
  return;
}

// puts @ 001011b0


[GOOD CHAIN 3] goodB2G2 -> FUN_001016f1 -> puts
// goodB2G2 @ 00101503

void FUN_00101503(void)

{
  long in_FS_OFFSET;
  char local_12;
  char local_11;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_12 = ' ';
  if (DAT_00104010 != 0) {
    __isoc99_fscanf(stdin,&DAT_00102008,&local_12);
  }
  if (DAT_00104010 != 0) {
    if (local_12 == '\x7f') {
      FUN_001016f1("data value is too large to perform arithmetic safely.");
    }
    else {
      local_12 = local_12 + '\x01';
      local_11 = local_12;
      FUN_0010186b((int)local_12);
    }
  }
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return;
}

// FUN_001016f1 @ 001016f1

void FUN_001016f1(char *param_1)

{
  if (param_1 != (char *)0x0) {
    puts(param_1);
  }
  return;
}

// puts @ 001011b0


[GOOD CHAIN 4] goodG2B1 -> FUN_001016f1 -> puts
// goodG2B1 @ 001015a4

void FUN_001015a4(void)

{
  char local_a;
  
  local_a = ' ';
  if (DAT_0010402c == 0) {
    local_a = '\x02';
  }
  else {
    FUN_001016f1("Benign, fixed string");
  }
  if (DAT_00104010 != 0) {
    FUN_0010186b(local_a + '\x01');
  }
  return;
}

// FUN_001016f1 @ 001016f1

void FUN_001016f1(char *param_1)

{
  if (param_1 != (char *)0x0) {
    puts(param_1);
  }
  return;
}

// puts @ 001011b0



---

